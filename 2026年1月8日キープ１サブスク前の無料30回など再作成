import SwiftUI
import AVFoundation
import Speech
import Accelerate
import Combine   // â† è¿½åŠ ï¼ˆObservableObject / @Published ç”¨ï¼‰
import StoreKit  // â† ã‚µãƒ–ã‚¹ã‚¯ç”¨

#if canImport(Translation)
import Translation
#endif

// =====================================
// å…±é€šã‚³ãƒ³ãƒ•ã‚£ã‚°ï¼ˆè¨€èªãƒ»IDãªã©ã‚’ã“ã“ã§åˆ‡ã‚Šæ›¿ãˆï¼‰
// =====================================
struct DoujituConfig {
    // è¡¨ç¤ºå
    let appDisplayName: String

    // StoreKit
    let subscriptionProductID: String

    // ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼
    let privacyPolicyURL: URL

    // ç¿»è¨³è¨€èªã‚³ãƒ¼ãƒ‰ï¼ˆTranslation.framework ç”¨ï¼‰
    let userLangCode: String      // ä¾‹: "ja"
    let partnerLangCode: String   // ä¾‹: "hi"

    // ASR ãƒ­ã‚±ãƒ¼ãƒ«
    let userASRLocale: String     // ä¾‹: "ja-JP"
    let partnerASRLocale: String  // ä¾‹: "hi-IN"

    // TTS ç”¨è¨€èªã‚³ãƒ¼ãƒ‰
    let partnerTTSLocale: String  // ä¾‹: "hi-IN"

    // ãƒ­ã‚°ä¿å­˜é–¢é€£
    let logsFolderName: String        // ä¾‹: "DoujituHILogs"
    let logFilePrefix: String         // ä¾‹: "doujituHI"
    let viToJaLogFilePrefix: String   // ä¾‹: "doujituHI_HItoJA"

    // è¿½åŠ ãƒ‡ãƒ¼ã‚¿åŒæ„ç”¨ã‚­ãƒ¼
    let resourceConsentUserDefaultsKey: String // ä¾‹: "DoujituHI_ResourceDownloadConsent_v1"
}

// â˜… ã“ã“ã‚’æ›¸ãæ›ãˆã‚‹ã ã‘ã§ã€åˆ¥è¨€èªç‰ˆã‚’ä½œã‚Œã‚‹
let appConfig = DoujituConfig(
    appDisplayName: "doujituHI",
    subscriptionProductID: "DoujituHI_monthly",
    privacyPolicyURL: URL(string: "https://your-privacy-policy-url.example.com")!,
    userLangCode: "ja",
    partnerLangCode: "hi",
    userASRLocale: "ja-JP",
    partnerASRLocale: "hi-IN",
    partnerTTSLocale: "hi-IN",
    logsFolderName: "DoujituHILogs",
    logFilePrefix: "doujituHI",
    viToJaLogFilePrefix: "doujituHI_HItoJA",
    resourceConsentUserDefaultsKey: "DoujituHI_ResourceDownloadConsent_v1"
)

// =====================================
// âœ… ç„¡æ–™å›æ•°ãƒªãƒŸãƒƒã‚¿ãƒ¼ï¼ˆ30å›ï¼‰
// - ã€Œæ—¥æœ¬èªâ†’ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èªã€ã®ç¢ºå®šç¿»è¨³ï¼ˆPTTã‚’é›¢ã—ã¦ç¿»è¨³ç¢ºå®šï¼‰ã ã‘ã‚«ã‚¦ãƒ³ãƒˆ
// - è³¼èª­ä¸­ã¯ç„¡åˆ¶é™ï¼ˆã‚«ã‚¦ãƒ³ãƒˆã—ãªã„ï¼‰
// - â˜… RootView å´ã®åˆ¤å®šã‚’å®‰å®šåŒ–ã™ã‚‹ãŸã‚ quotaTotal / didHitLimit ã‚’å…¬é–‹
// =====================================
@MainActor
final class FreeUsageLimiter: ObservableObject {
    static let shared = FreeUsageLimiter()

    // ğŸ”½ ã“ã“ã ã‘å¤‰ãˆã‚Œã°ç„¡æ–™å›æ•°ãŒå¤‰ã‚ã‚‹
    // â˜… RootView ç­‰ã‹ã‚‰å‚ç…§ã™ã‚‹ã®ã§ private ã‚’å¤–ã™
    let quotaTotal = 30

    private let usedKey = "doujituHI_free_translate_used_count_v1"

    @Published private(set) var usedCount: Int = 0
    @Published private(set) var remaining: Int = 30

    /// è³¼èª­ä¸­ã¯ç„¡åˆ¶é™
    @Published var isUnlimited: Bool = false {
        didSet { recompute() }
    }

    /// â˜… ä¸Šé™åˆ°é”ãƒ•ãƒ©ã‚°ï¼ˆRootView ã®åˆ‡æ›¿æ¡ä»¶ã‚’ç¢ºå®ŸåŒ–ï¼‰
    @Published private(set) var didHitLimit: Bool = false

    private init() {
        let used = UserDefaults.standard.integer(forKey: usedKey)
        usedCount = max(0, used)
        recompute()
    }

    private func recompute() {
        if isUnlimited {
            remaining = quotaTotal
            didHitLimit = false
        } else {
            remaining = max(0, quotaTotal - usedCount)
            didHitLimit = (usedCount >= quotaTotal)
        }
    }

    /// âœ… 1å›æ¶ˆè²»ï¼ˆæ®‹ã£ã¦ã„ãªã‘ã‚Œã° falseï¼‰
    /// â˜… 30å›ç›®ã¯é€šã‚‹ï¼31å›ç›®ã§ false ã«ãªã‚‹ã®ã¯ä»•æ§˜ä¸Šè‡ªç„¶ã€‚
    ///   ãŸã ã— RootView ã¯ didHitLimit ã‚’è¦‹ã¦ã€Œ30å›ä½¿ã„åˆ‡ã£ãŸç¬é–“ã€ã«èª˜å°ã¸åˆ‡æ›¿å¯èƒ½ã€‚
    func consumeOneIfPossible() -> Bool {
        if isUnlimited { return true }

        // ã‚‚ã†ä¸Šé™ã«é”ã—ã¦ã„ã‚‹ãªã‚‰æ¶ˆè²»ä¸å¯
        if usedCount >= quotaTotal {
            recompute()
            return false
        }

        usedCount += 1
        UserDefaults.standard.set(usedCount, forKey: usedKey)
        recompute()
        return true
    }

    ///ï¼ˆå¿…è¦ãªã‚‰ï¼‰ãƒ‡ãƒãƒƒã‚°ç”¨ãƒªã‚»ãƒƒãƒˆ
    func debugReset() {
        UserDefaults.standard.removeObject(forKey: usedKey)
        usedCount = 0
        recompute()
    }
}

// =====================================
// Subscription (StoreKit2) for doujituHI
// =====================================
@MainActor
final class SubscriptionStore: ObservableObject {
    @Published var product: Product?
    @Published var isSubscribed: Bool = false
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?

    /// â˜… è³¼èª­çŠ¶æ…‹ã®ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ãŸã‹ã©ã†ã‹
    @Published var hasCheckedSubscriptionStatus: Bool = false

    /// App Store Connect ã§ä½œæˆã—ãŸã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ID
    /// â˜… å¿…ãš App Store Connect ä¸Šã® Product ID ã¨ä¸€è‡´ã•ã›ã‚‹
    private let productID: String

    init(config: DoujituConfig) {
        self.productID = config.subscriptionProductID
        Task {
            await refresh()
            await observeTransactions()
        }
    }

    /// å•†å“æƒ…å ±èª­ã¿è¾¼ã¿ & è³¼èª­çŠ¶æ…‹æ›´æ–°
    func refresh() async {
        isLoading = true
        defer { isLoading = false }

        do {
            let products = try await Product.products(for: [productID])
            if let first = products.first {
                product = first
                errorMessage = nil
            } else {
                product = nil
                errorMessage = "ç¾åœ¨ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
            }
            await updateSubscriptionStatus()
        } catch {
            product = nil
            errorMessage = "ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚é€šä¿¡ç’°å¢ƒã‚„App Storeã®è¨­å®šã‚’ã”ç¢ºèªã®ã†ãˆã€æ™‚é–“ã‚’ãŠã„ã¦ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
            print("Failed to load products: \(error)")
            await updateSubscriptionStatus()
        }
    }

    /// è³¼å…¥å‡¦ç†ï¼ˆ7æ—¥é–“ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ã¯ App Store Connect å´ã§è¨­å®šï¼‰
    func purchase() async {
        guard let product else {
            errorMessage = "ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
            return
        }
        isLoading = true
        defer { isLoading = false }

        do {
            let result = try await product.purchase()
            switch result {
            case .success(let verification):
                let transaction = try checkVerified(verification)
                await updateSubscriptionStatus()
                await transaction.finish()
                errorMessage = nil
            case .userCancelled:
                break
            case .pending:
                errorMessage = "è³¼å…¥å‡¦ç†ãŒä¿ç•™ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
            default:
                break
            }
        } catch {
            errorMessage = "è³¼å…¥ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
            print("Purchase error: \(error)")
        }
    }

    /// è³¼å…¥ã®å¾©å…ƒ
    func restore() async {
        isLoading = true
        defer { isLoading = false }

        do {
            var found = false
            for await result in Transaction.currentEntitlements {
                let transaction = try checkVerified(result)
                if transaction.productID == productID,
                   transaction.revocationDate == nil,
                   !transaction.isUpgraded {
                    found = true
                    isSubscribed = true
                    break
                }
            }
            hasCheckedSubscriptionStatus = true

            if !found {
                errorMessage = "æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
            } else {
                errorMessage = nil
            }
        } catch {
            errorMessage = "è³¼å…¥å±¥æ­´ã®å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚é€šä¿¡ç’°å¢ƒã‚’ã”ç¢ºèªã®ã†ãˆã€ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
            print("Restore error: \(error)")
        }
    }

    /// ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç›£è¦–
    func observeTransactions() async {
        for await result in Transaction.updates {
            do {
                let transaction = try checkVerified(result)
                if transaction.productID == productID {
                    isSubscribed = (transaction.revocationDate == nil && !transaction.isUpgraded)
                    hasCheckedSubscriptionStatus = true
                }
                await transaction.finish()
            } catch {
                print("Transaction update verification failed: \(error)")
            }
        }
    }

    /// ç¾åœ¨ã®è³¼èª­çŠ¶æ…‹ã‚’æ›´æ–°
    func updateSubscriptionStatus() async {
        var active = false
        for await result in Transaction.currentEntitlements {
            do {
                let transaction = try checkVerified(result)
                if transaction.productID == productID,
                   transaction.revocationDate == nil,
                   !transaction.isUpgraded {
                    active = true
                    break
                }
            } catch {
                print("updateSubscriptionStatus verification failed: \(error)")
            }
        }
        isSubscribed = active
        hasCheckedSubscriptionStatus = true
    }

    /// StoreKit ç½²åæ¤œè¨¼
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .unverified(_, let error):
            throw error
        case .verified(let signedType):
            return signedType
        }
    }
}

// =====================================
// ã‚µãƒ–ã‚¹ã‚¯ç”»é¢ View
// =====================================
struct SubscriptionView: View {
    @EnvironmentObject private var subscriptionStore: SubscriptionStore

    private let eulaURL = URL(string: "https://www.apple.com/legal/internet-services/itunes/dev/stdeula/")!

    var body: some View {
        NavigationStack {
            VStack(spacing: 24) {
                Spacer(minLength: 20)

                VStack(spacing: 8) {
                    Text(appConfig.appDisplayName)
                        .font(.system(size: 28, weight: .heavy, design: .rounded))
                        .tracking(1.5)

                    Text("æ—¥æœ¬èªã§ãã®ã¾ã¾è©±ãã†ï¼")
                        .font(.headline)
                        .foregroundColor(.primary)

                    Text("ã‚ãªãŸã¯æ—¥æœ¬èªã§è©±ã™ã ã‘ï¼ç›¸æ‰‹ã®ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èªã¯è‡ªå‹•ã§èãå–ã‚Šã€ç¿»è¨³æ–‡å­—ãŒè¡¨ç¤ºã•ã‚Œç¶šã‘ã‚‹é€šè¨³ã‚¢ãƒ—ãƒªã§ã™ã€‚")
                        .font(.subheadline)
                        .multilineTextAlignment(.center)
                        .foregroundColor(.secondary)
                        .padding(.horizontal)
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.pink.opacity(0.18),
                                    Color.orange.opacity(0.15)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                )
                .padding(.horizontal)

                VStack(spacing: 12) {
                    Text("7æ—¥é–“ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«")
                        .font(.headline)

                    Text(
                        subscriptionStore.product?.displayPrice != nil
                        ? "ã¾ãšã¯7æ—¥é–“ã€ã™ã¹ã¦ã®æ©Ÿèƒ½ã‚’ç„¡æ–™ã§ãŠè©¦ã—ã„ãŸã ã‘ã¾ã™ã€‚ãã®å¾Œã¯è‡ªå‹•çš„ã« \(subscriptionStore.product!.displayPrice) / æœˆ ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚ã„ã¤ã§ã‚‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ã§ã™ã€‚"
                        : "ã¾ãšã¯7æ—¥é–“ã€ã™ã¹ã¦ã®æ©Ÿèƒ½ã‚’ç„¡æ–™ã§ãŠè©¦ã—ã„ãŸã ã‘ã¾ã™ã€‚ä¾¡æ ¼æƒ…å ±ã®å–å¾—ä¸­ã€ã¾ãŸã¯ä¸€æ™‚çš„ã«å–å¾—ã§ããªã„çŠ¶æ…‹ã§ã™ã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
                    )
                    .font(.footnote)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                }

                VStack(spacing: 12) {
                    Button {
                        Task { await subscriptionStore.purchase() }
                    } label: {
                        HStack {
                            Spacer()
                            Text(subscriptionStore.product?.displayPrice != nil
                                 ? "7æ—¥é–“ç„¡æ–™ã§è©¦ã™ï¼ˆãã®å¾Œ \(subscriptionStore.product!.displayPrice)/æœˆï¼‰"
                                 : "7æ—¥é–“ç„¡æ–™ã§è©¦ã™")
                                .fontWeight(.semibold)
                                .padding(.vertical, 12)
                            Spacer()
                        }
                        .background(
                            LinearGradient(
                                colors: [Color.pink, Color.orange],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .cornerRadius(14)
                        .shadow(radius: 3, y: 2)
                    }
                    .disabled(subscriptionStore.isLoading)

                    Button {
                        Task { await subscriptionStore.restore() }
                    } label: {
                        Text("è³¼å…¥ã‚’å¾©å…ƒ")
                            .font(.subheadline)
                    }
                    .padding(.top, 4)

                    if let err = subscriptionStore.errorMessage, !err.isEmpty {
                        Text(err)
                            .font(.footnote)
                            .foregroundColor(.red)
                            .multilineTextAlignment(.center)
                            .padding(.top, 4)
                            .padding(.horizontal)
                    }
                }
                .padding(.horizontal)

                Spacer()

                HStack(spacing: 16) {
                    Link("ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼", destination: appConfig.privacyPolicyURL)
                    Link("EULAï¼ˆåˆ©ç”¨è¦ç´„ï¼‰", destination: eulaURL)
                }
                .font(.footnote)
                .padding(.bottom, 12)
            }
            .navigationTitle("ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³")
            .toolbar {
                if subscriptionStore.isLoading {
                    ProgressView()
                }
            }
            .task {
                await subscriptionStore.refresh()
            }
        }
    }
}

// =====================================
// âœ… ç„¡æ–™30å›ã‚’ä½¿ã„åˆ‡ã£ãŸå¾Œã«å‡ºã™ã€Œèª˜å°ã€ç”»é¢
// =====================================
struct TrialEndedGateView: View {
    @EnvironmentObject private var subscriptionStore: SubscriptionStore
    @EnvironmentObject private var freeLimiter: FreeUsageLimiter

    let onGoToSubscription: () -> Void

    var body: some View {
        NavigationStack {
            VStack(spacing: 18) {
                Spacer(minLength: 24)

                VStack(spacing: 8) {
                    Text("ç„¡æ–™\(freeLimiter.quotaTotal)å›ã‚’ä½¿ã„åˆ‡ã‚Šã¾ã—ãŸ")
                        .font(.system(size: 22, weight: .heavy, design: .rounded))

                    Text("ç¶šã‘ã‚‹ã«ã¯ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒå¿…è¦ã§ã™ã€‚")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(Color(.secondarySystemBackground))
                )
                .padding(.horizontal)

                VStack(spacing: 10) {
                    Button {
                        onGoToSubscription()
                    } label: {
                        HStack {
                            Spacer()
                            Text("ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¦‹ã‚‹")
                                .fontWeight(.semibold)
                                .padding(.vertical, 12)
                            Spacer()
                        }
                        .background(
                            LinearGradient(
                                colors: [Color.pink, Color.orange],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .cornerRadius(14)
                        .shadow(radius: 3, y: 2)
                    }

                    Button {
                        Task { await subscriptionStore.restore() }
                    } label: {
                        Text("è³¼å…¥ã‚’å¾©å…ƒ")
                            .font(.subheadline)
                    }

                    if let err = subscriptionStore.errorMessage, !err.isEmpty {
                        Text(err)
                            .font(.footnote)
                            .foregroundColor(.red)
                            .multilineTextAlignment(.center)
                            .padding(.top, 6)
                            .padding(.horizontal)
                    }
                }
                .padding(.horizontal)

                Spacer()

                VStack(spacing: 6) {
                    if freeLimiter.isUnlimited {
                        Text("ç¾åœ¨ï¼šè³¼èª­ä¸­ï¼ˆç„¡åˆ¶é™ï¼‰")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    } else {
                        Text("ç„¡æ–™åˆ©ç”¨ï¼š\(freeLimiter.quotaTotal)å›ã¾ã§ï¼ˆä½¿ç”¨æ¸ˆã¿ï¼š\(min(freeLimiter.usedCount, freeLimiter.quotaTotal))å›ï¼‰")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
                .padding(.bottom, 16)
            }
            .navigationTitle("ã”æ¡ˆå†…")
        }
    }
}

// =====================================
// RootViewï¼ˆã‚µãƒ–ã‚¹ã‚¯çŠ¶æ…‹/ç„¡æ–™å›æ•°ã§åˆ‡ã‚Šæ›¿ãˆï¼‰
// â˜… remaining ä¾å­˜ã‚’ã‚„ã‚ã€usedCount/quotaTotal/didHitLimit ã§ç¢ºå®ŸåŒ–
// =====================================
struct RootView: View {
    @EnvironmentObject private var subscriptionStore: SubscriptionStore
    @EnvironmentObject private var freeLimiter: FreeUsageLimiter

    @State private var goToSubscriptionNow: Bool = false

    private var isFreeAvailable: Bool {
        if freeLimiter.isUnlimited { return true }
        return freeLimiter.usedCount < freeLimiter.quotaTotal
    }

    var body: some View {
        Group {
            if !subscriptionStore.hasCheckedSubscriptionStatus {
                SubscriptionView()
            } else if subscriptionStore.isSubscribed {
                ContentView()
            } else {
                // éè³¼èª­ï¼šç„¡æ–™æ ãŒæ®‹ã£ã¦ã„ã‚Œã°ä½¿ãˆã‚‹ï¼ˆâ˜… usedCount ãƒ™ãƒ¼ã‚¹ï¼‰
                if isFreeAvailable {
                    ContentView()
                } else {
                    // âœ… ç„¡æ–™çµ‚äº† â†’ ã¾ãšèª˜å°ç”»é¢ â†’ ãã“ã‹ã‚‰ã‚µãƒ–ã‚¹ã‚¯ç”»é¢ã¸
                    if goToSubscriptionNow {
                        SubscriptionView()
                    } else {
                        TrialEndedGateView {
                            goToSubscriptionNow = true
                        }
                    }
                }
            }
        }
        .animation(.easeInOut, value: subscriptionStore.isSubscribed)
        .onAppear {
            freeLimiter.isUnlimited = subscriptionStore.isSubscribed
        }
        .onChange(of: subscriptionStore.isSubscribed) { newValue in
            freeLimiter.isUnlimited = newValue
            if newValue {
                goToSubscriptionNow = false
            }
        }
        // â˜… ä½¿ã„åˆ‡ã£ãŸç¬é–“ã«ã€ContentView è¡¨ç¤ºä¸­ã§ã‚‚ RootView ãŒç¢ºå®Ÿã«åˆ‡ã‚Šæ›¿ã‚ã‚‹ã‚ˆã†ã«
        .onChange(of: freeLimiter.didHitLimit) { hit in
            if hit {
                goToSubscriptionNow = false
            }
        }
    }
}

// =====================================
// App
// =====================================
@main
struct doujituHIApp: App {
    @StateObject private var subscriptionStore = SubscriptionStore(config: appConfig)
    @StateObject private var freeLimiter = FreeUsageLimiter.shared

    var body: some Scene {
        WindowGroup {
            RootView()
                .environmentObject(subscriptionStore)
                .environmentObject(freeLimiter)
        }
    }
}

// =====================================
// ASRï¼ˆé€£ç¶šèªè­˜ï¼ä¸€æ™‚åœæ­¢ï¼1101ãƒªãƒˆãƒ©ã‚¤ä»˜ãï¼‰
// =====================================
final class ASRService: NSObject {
    private let recognizer: SFSpeechRecognizer?
    private let audioEngine = AVAudioEngine()
    private var request: SFSpeechAudioBufferRecognitionRequest?
    private var task: SFSpeechRecognitionTask?

    private let preferredSampleRate: Double

    private(set) var didEmitFinal = false
    private var onPartialHandler: ((String)->Void)?
    private var onFinalHandler: ((String)->Void)?

    private var retryCount = 0
    private let maxRetry = 2
    private var isStarting = false
    private var paused = false

    private var inputTapInstalled = false

    init(localeIdentifier: String, preferredSampleRate: Double = 44_100) {
        self.recognizer = SFSpeechRecognizer(locale: Locale(identifier: localeIdentifier))
        self.preferredSampleRate = preferredSampleRate
        super.init()
    }

    @MainActor
    func requestAuthorization() async throws {
        let status = await withCheckedContinuation { (cont: CheckedContinuation<SFSpeechRecognizerAuthorizationStatus, Never>) in
            SFSpeechRecognizer.requestAuthorization { cont.resume(returning: $0) }
        }
        guard status == .authorized else {
            throw NSError(domain: "ASR", code: 1, userInfo: [NSLocalizedDescriptionKey: "éŸ³å£°èªè­˜ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“"])
        }
    }

    @MainActor
    func startContinuous(onPartial: @escaping (String)->Void,
                         onFinal: @escaping (String)->Void) throws {
        if isStarting { return }
        isStarting = true
        defer { isStarting = false }

        paused = false
        cancelAll()
        didEmitFinal = false
        retryCount = 0
        onPartialHandler = onPartial
        onFinalHandler = onFinal

        try configureAndStartEngine()
        startRecognitionTask()
    }

    @MainActor
    func pause() {
        paused = true
        if inputTapInstalled {
            audioEngine.inputNode.removeTap(onBus: 0)
            inputTapInstalled = false
        }
    }

    @MainActor
    func resume(onPartial: @escaping (String)->Void,
                onFinal: @escaping (String)->Void) {
        guard paused else { return }
        paused = false
        onPartialHandler = onPartial
        onFinalHandler = onFinal

        if let req = self.request, audioEngine.isRunning {
            installInputTap(using: req)
            return
        }
        do {
            try configureAndStartEngine()
            startRecognitionTask()
        } catch {
            cancelAll()
        }
    }

    @MainActor
    func finishInput() {
        if inputTapInstalled {
            audioEngine.inputNode.removeTap(onBus: 0)
            inputTapInstalled = false
        }
        if audioEngine.isRunning { audioEngine.stop() }
        request?.endAudio()
    }

    @MainActor
    func cancelAll() {
        if inputTapInstalled {
            audioEngine.inputNode.removeTap(onBus: 0)
            inputTapInstalled = false
        }
        if audioEngine.isRunning {
            audioEngine.stop()
        }
        audioEngine.reset()
        request?.endAudio()
        task?.cancel()
        task = nil
        request = nil
    }

    @MainActor
    private func installInputTap(using req: SFSpeechAudioBufferRecognitionRequest) {
        guard !inputTapInstalled else { return }

        let session = AVAudioSession.sharedInstance()
        var sr = session.sampleRate
        if sr <= 0 {
            sr = preferredSampleRate > 0 ? preferredSampleRate : 44_100
        }

        guard let fmt = AVAudioFormat(commonFormat: .pcmFormatFloat32,
                                      sampleRate: sr,
                                      channels: 1,
                                      interleaved: false) else { return }

        let input = audioEngine.inputNode
        input.installTap(onBus: 0, bufferSize: 2048, format: fmt) { [weak req] buffer, _ in
            req?.append(buffer)
        }
        inputTapInstalled = true
    }

    @MainActor
    private func configureAndStartEngine() throws {
        let session = AVAudioSession.sharedInstance()

        try? session.setActive(false, options: [.notifyOthersOnDeactivation])

        let targetSR = preferredSampleRate > 0 ? preferredSampleRate : 44_100

        try session.setCategory(.playAndRecord,
                                mode: .measurement,
                                options: [.duckOthers, .defaultToSpeaker])

        if let builtIn = session.availableInputs?.first(where: { $0.portType == .builtInMic }) {
            try? session.setPreferredInput(builtIn)
        }
        try? session.setPreferredInputNumberOfChannels(1)
        try? session.setPreferredSampleRate(targetSR)
        try? session.setPreferredIOBufferDuration(0.01)
        try session.setActive(true, options: .notifyOthersOnDeactivation)

        var sr = session.sampleRate
        if sr <= 0 { sr = targetSR }

        let req = SFSpeechAudioBufferRecognitionRequest()
        req.shouldReportPartialResults = true
        if #available(iOS 13.0, *), recognizer?.supportsOnDeviceRecognition == true {
            req.requiresOnDeviceRecognition = true
        }
        self.request = req

        installInputTap(using: req)

        audioEngine.reset()
        audioEngine.prepare()
        try audioEngine.start()
    }

    @MainActor
    private func startRecognitionTask() {
        guard let req = self.request else { return }

        task = recognizer?.recognitionTask(with: req) { [weak self] result, error in
            Task { @MainActor [weak self] in
                guard let self else { return }

                if let r = result {
                    let text = r.bestTranscription.formattedString
                    if r.isFinal {
                        self.didEmitFinal = true
                        self.onFinalHandler?(text)
                    } else {
                        self.onPartialHandler?(text)
                    }
                }

                if let nsErr = error as NSError? {
                    if nsErr.domain == "kAFAssistantErrorDomain",
                       nsErr.code == 1101,
                       self.retryCount < self.maxRetry,
                       !self.paused {
                        self.retryCount += 1
                        let delay: UInt64 = self.retryCount == 1 ? 100_000_000 : 300_000_000
                        self.softRestart(afterNsec: delay)
                        return
                    }
                    self.cancelAll()
                }
            }
        }
    }

    @MainActor
    private func softRestart(afterNsec: UInt64) {
        if inputTapInstalled {
            audioEngine.inputNode.removeTap(onBus: 0)
            inputTapInstalled = false
        }
        if audioEngine.isRunning {
            audioEngine.stop()
        }
        audioEngine.reset()
        request?.endAudio()
        task?.cancel()
        task = nil
        request = nil

        Task { @MainActor [weak self] in
            guard let self else { return }
            try? await Task.sleep(nanoseconds: afterNsec)
            guard !self.paused else { return }
            do {
                try self.configureAndStartEngine()
                self.startRecognitionTask()
            } catch {
                self.cancelAll()
            }
        }
    }
}

// =====================================
// TTSï¼ˆç›¸æ‰‹è¨€èª=ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èªï¼‰â€” çˆ†éŸ³å›ºå®šç‰ˆ
// =====================================
@MainActor
final class TTSSpeaker: NSObject, AVSpeechSynthesizerDelegate {
    var boostDB: Float = 18.0

    private let synth = AVSpeechSynthesizer()

    @Published var isSpeaking = false

    var onFinish: (() -> Void)?
    private var didNotifyFinish = false
    private var finishWaiters: [CheckedContinuation<Void, Never>] = []

    override init() {
        super.init()
        synth.delegate = self
    }

    func stopImmediately() {
        synth.stopSpeaking(at: .immediate)
        isSpeaking = false
        didNotifyFinish = false
        resumeWaiters()
    }

    func speakEnglish(_ text: String) {
        stopImmediately()
        didNotifyFinish = false

        let session = AVAudioSession.sharedInstance()
        try? session.setCategory(.playback,
                                 mode: .default,
                                 options: [.duckOthers])
        try? session.overrideOutputAudioPort(.speaker)
        try? session.setActive(true, options: [.notifyOthersOnDeactivation])

        let u = AVSpeechUtterance(string: text)
        u.voice = AVSpeechSynthesisVoice(language: appConfig.partnerTTSLocale)
        u.rate = AVSpeechUtteranceDefaultSpeechRate
        u.volume = 1.0

        isSpeaking = true
        synth.speak(u)
    }

    private func notifyFinishOnceWithDelay() {
        guard !didNotifyFinish else { return }
        didNotifyFinish = true
        Task { @MainActor [weak self] in
            guard let self else { return }
            try? await Task.sleep(nanoseconds: 300_000_000)
            self.onFinish?()
        }
    }

    func awaitFinish(timeout: TimeInterval = 25) async {
        if !isSpeaking { return }
        let timeoutNs = UInt64(max(0, timeout) * 1_000_000_000)
        await withTaskGroup(of: Void.self) { group in
            group.addTask { [weak self] in
                await withCheckedContinuation { (cont: CheckedContinuation<Void, Never>) in
                    Task { @MainActor [weak self] in
                        guard let self else { return }
                        self.finishWaiters.append(cont)
                    }
                }
            }
            group.addTask {
                try? await Task.sleep(nanoseconds: timeoutNs)
            }
            _ = await group.next()
        }
        if isSpeaking {
            Task { @MainActor [weak self] in
                self?.stopImmediately()
            }
        }
    }

    @MainActor
    private func resumeWaiters() {
        let waiters = finishWaiters
        finishWaiters.removeAll()
        for w in waiters { w.resume() }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer,
                                       didStart utterance: AVSpeechUtterance) {
        Task { @MainActor [weak self] in self?.isSpeaking = true }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer,
                                       didFinish utterance: AVSpeechUtterance) {
        Task { @MainActor [weak self] in
            guard let self else { return }
            self.isSpeaking = false
            self.notifyFinishOnceWithDelay()
            self.resumeWaiters()
        }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer,
                                       didCancel utterance: AVSpeechUtterance) {
        Task { @MainActor [weak self] in
            guard let self else { return }
            self.isSpeaking = false
            self.resumeWaiters()
        }
    }
}

// =====================================
// ä¼šè©±ãƒ­ã‚°ãƒ¢ãƒ‡ãƒ«ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ç”¨ï¼‰
// =====================================
struct ConversationLog: Identifiable, Hashable {
    let id: UUID
    let url: URL
    let createdAt: Date

    var displayName: String { url.deletingPathExtension().lastPathComponent }

    var formattedDate: String {
        let df = DateFormatter()
        df.locale = Locale(identifier: "ja_JP")
        df.dateFormat = "yyyy/MM/dd HH:mm"
        return df.string(from: createdAt)
    }
}

// =====================================
// ViewModelï¼ˆHIâ†”JA + ãƒ­ã‚° + ã‚´ãƒŸç®±ï¼‰
// =====================================
@MainActor
final class DoujituVM: ObservableObject {
    @Published var enLivePartial: String = ""
    @Published var enLiveFinal: String = ""
    @Published var jaFromEN: String = ""
    @Published var isENContinuousRunning = false

    @Published var partialJA: String = ""
    @Published var finalJA:   String = ""
    @Published var enFromJA:  String = ""
    @Published var isRecordingJA = false
    @Published var isTranslating = false
    @Published var errorMessage: String?

    @Published var gainDB: Float = 18.0 {
        didSet { tts.boostDB = gainDB }
    }

    @Published var isLoggingEnabled: Bool = true {
        didSet {
            if !isLoggingEnabled {
                flushCurrentLogToFile()
            }
        }
    }

    @Published var savedLogs: [ConversationLog] = []
    @Published var trashedLogs: [ConversationLog] = []

    /// âœ… ç„¡æ–™å›æ•°ï¼ˆè³¼èª­ä¸­ã¯ç„¡åˆ¶é™ï¼‰
    private let freeLimiter = FreeUsageLimiter.shared

    let asrEN = ASRService(localeIdentifier: appConfig.partnerASRLocale, preferredSampleRate: 48_000)
    let asrJA = ASRService(localeIdentifier: appConfig.userASRLocale)
    let tts = TTSSpeaker()

    #if canImport(Translation)
    @Published var tConfigJAtoEN: TranslationSession.Configuration? = .init(
        source: .init(identifier: appConfig.userLangCode),
        target: .init(identifier: appConfig.partnerLangCode)
    )
    @Published var tConfigENtoJA: TranslationSession.Configuration? = .init(
        source: .init(identifier: appConfig.partnerLangCode),
        target: .init(identifier: appConfig.userLangCode)
    )
    private var sessionJAtoEN: TranslationSession?
    private var sessionENtoJA: TranslationSession?
    @Published var isSystemTranslationAvailable: Bool = true
    #endif

    private var enDebounceTask: Task<Void, Never>?
    private var jaTranslateTask: Task<Void, Never>?

    private var enAuthorized = false

    private var currentLogStartDate: Date?
    private var currentLogBuffer: String = ""
    private var enToJaOnlyBuffer: String = ""

    private static let logTimeFormatter: DateFormatter = {
        let df = DateFormatter()
        df.locale = Locale(identifier: "ja_JP")
        df.dateFormat = "yyyy/MM/dd HH:mm:ss"
        return df
    }()

    init() {
        tts.boostDB = gainDB
        tts.onFinish = { [weak self] in
            Task { @MainActor [weak self] in
                guard let self else { return }
                await self.startENContinuous()
            }
        }
        loadExistingLogs()
    }

    #if canImport(Translation)
    func bindSessionJAtoEN(_ s: TranslationSession) async {
        guard isSystemTranslationAvailable else { return }
        sessionJAtoEN = s
        do {
            try await s.prepareTranslation()
            _ = try? await s.translate("ã“ã‚Œã¯ç¿»è¨³ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ç”¨ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚")
        } catch {
            handleTranslationSetupError(error, direction: "JAâ†’\(appConfig.partnerLangCode.uppercased())")
            isSystemTranslationAvailable = false
        }
    }

    func bindSessionENtoJA(_ s: TranslationSession) async {
        guard isSystemTranslationAvailable else { return }
        sessionENtoJA = s
        do {
            try await s.prepareTranslation()
            _ = try? await s.translate("à¤¨à¤®à¤¸à¥à¤¤à¥‡")
        } catch {
            handleTranslationSetupError(error, direction: "\(appConfig.partnerLangCode.uppercased())â†’JA")
            isSystemTranslationAvailable = false
        }
    }

    private func handleTranslationSetupError(_ error: Error, direction: String) {
        let nsErr = error as NSError
        if nsErr.domain == "TranslationErrorDomain" || nsErr.code == 4097 {
            errorMessage = "ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³ï¼ˆ\(direction)ï¼‰ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚\nç¿»è¨³çµæœã®ä»£ã‚ã‚Šã«å…ƒã®æ–‡ç« ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚"
        } else {
            errorMessage = "ç¿»è¨³æº–å‚™ã‚¨ãƒ©ãƒ¼(\(direction)): \(nsErr.localizedDescription)"
        }
    }
    #endif

    // =============================
    // ç›¸æ‰‹è¨€èª â†’ æ—¥æœ¬èªï¼ˆå¸¸æ™‚ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰
    // =============================
    func startENContinuous() async {
        guard !isENContinuousRunning else { return }
        do {
            if !enAuthorized {
                try await asrEN.requestAuthorization()
                enAuthorized = true
            }
            try asrEN.startContinuous(onPartial: { [weak self] text in
                guard let self else { return }
                self.enLivePartial = text
                self.scheduleQuickTranslateFromEN()
            }, onFinal: { [weak self] text in
                guard let self else { return }
                self.enLiveFinal = text
                self.scheduleQuickTranslateFromEN()
            })
            isENContinuousRunning = true
        } catch {
            errorMessage = "ç›¸æ‰‹è¨€èª å¸¸æ™‚èªè­˜é–‹å§‹ã‚¨ãƒ©ãƒ¼: \(error.localizedDescription)"
        }
    }

    private func pauseENContinuous() {
        asrEN.pause()
        isENContinuousRunning = false
    }

    private func stopENContinuousCompletely() {
        asrEN.cancelAll()
        isENContinuousRunning = false
    }

    private func resumeENContinuous() {
        asrEN.resume(onPartial: { [weak self] text in
            guard let self else { return }
            self.enLivePartial = text
            self.scheduleQuickTranslateFromEN()
        }, onFinal: { [weak self] text in
            guard let self else { return }
            self.enLiveFinal = text
            self.scheduleQuickTranslateFromEN()
        })
        isENContinuousRunning = true
    }

    private func scheduleQuickTranslateFromEN() {
        let source = enLiveFinal.isEmpty ? enLivePartial : enLiveFinal
        guard !source.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }

        enDebounceTask?.cancel()
        enDebounceTask = Task { @MainActor [weak self] in
            guard let self else { return }
            try? await Task.sleep(nanoseconds: 350_000_000)
            if Task.isCancelled { return }
            await self.translateENtoJA(sourceEN: source)
        }
    }

    private func translateENtoJA(sourceEN: String) async {
        #if canImport(Translation)
        guard isSystemTranslationAvailable, let s = sessionENtoJA else {
            jaFromEN = "(ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³æœªå¯¾å¿œã®ãŸã‚åŸæ–‡ã‚’è¡¨ç¤º)\n\(sourceEN)"
            appendConversationEntry(
                speaker: "ç›¸æ‰‹",
                direction: "\(appConfig.partnerLangCode.uppercased())â†’JA",
                sourceLabel: "ç›¸æ‰‹è¨€èªï¼ˆåŸæ–‡ï¼‰",
                targetLabel: "æ—¥æœ¬èªï¼ˆåŸæ–‡ï¼‰",
                sourceText: sourceEN,
                targetText: jaFromEN
            )
            appendENtoJAStudyLine(jaFromEN)
            return
        }

        do {
            let res = try await s.translate(sourceEN)
            if Task.isCancelled { return }
            let translated = res.targetText
            jaFromEN = translated

            appendConversationEntry(
                speaker: "ç›¸æ‰‹",
                direction: "\(appConfig.partnerLangCode.uppercased())â†’JA",
                sourceLabel: "ç›¸æ‰‹è¨€èª",
                targetLabel: "æ—¥æœ¬èª",
                sourceText: sourceEN,
                targetText: translated
            )
            appendENtoJAStudyLine(translated)

        } catch is CancellationError {
            return
        } catch {
            let nsErr = error as NSError
            if nsErr.domain == "TranslationErrorDomain" || nsErr.code == 4097 {
                isSystemTranslationAvailable = false
                errorMessage = "ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³ï¼ˆ\(appConfig.partnerLangCode.uppercased())â†’JAï¼‰ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚\nåŸæ–‡è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚"
                jaFromEN = "(ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³ã‚¨ãƒ©ãƒ¼: åŸæ–‡ã‚’è¡¨ç¤º)\n\(sourceEN)"
            } else {
                errorMessage = "ç¿»è¨³ã‚¨ãƒ©ãƒ¼(\(appConfig.partnerLangCode.uppercased())â†’JA): \(nsErr.localizedDescription)"
            }

            appendConversationEntry(
                speaker: "ç›¸æ‰‹",
                direction: "\(appConfig.partnerLangCode.uppercased())â†’JA",
                sourceLabel: "ç›¸æ‰‹è¨€èªï¼ˆåŸæ–‡ï¼‰",
                targetLabel: "æ—¥æœ¬èªï¼ˆåŸæ–‡ï¼‰",
                sourceText: sourceEN,
                targetText: jaFromEN
            )
            appendENtoJAStudyLine(jaFromEN)
        }
        #else
        jaFromEN = "(Translationãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æœªå¯¾å¿œç’°å¢ƒ: \(appConfig.partnerLangCode.uppercased())â†’JA)"
        appendConversationEntry(
            speaker: "ç›¸æ‰‹",
            direction: "\(appConfig.partnerLangCode.uppercased())â†’JA",
            sourceLabel: "ç›¸æ‰‹è¨€èª",
            targetLabel: "æ—¥æœ¬èª",
            sourceText: sourceEN,
            targetText: jaFromEN
        )
        appendENtoJAStudyLine(jaFromEN)
        #endif
    }

    // =============================
    // æ—¥æœ¬èª â†’ ç›¸æ‰‹è¨€èªï¼ˆæŠ¼ã—ã¦è©±ã™ï¼‰
    // =============================
    func startRecordingJA() async {
        guard !isRecordingJA, !isTranslating else { return }

        // âœ… ç„¡æ–™æ ãŒå°½ããŸã‚‰é–‹å§‹ã•ã›ãªã„ï¼ˆRootView ãŒèª˜å°ç”»é¢ã¸åˆ‡æ›¿ï¼‰
        if !freeLimiter.isUnlimited && freeLimiter.usedCount >= freeLimiter.quotaTotal {
            errorMessage = "ç„¡æ–™\(freeLimiter.quotaTotal)å›ã‚’ä½¿ã„åˆ‡ã‚Šã¾ã—ãŸã€‚ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã”æ¤œè¨ãã ã•ã„ã€‚"
            return
        }

        isRecordingJA = true

        stopENContinuousCompletely()
        tts.stopImmediately()

        do {
            jaTranslateTask?.cancel()
            enFromJA = ""
            errorMessage = nil

            try await asrJA.requestAuthorization()
            partialJA = ""; finalJA = ""
            try asrJA.startContinuous(onPartial: { [weak self] text in
                self?.partialJA = text
            }, onFinal: { [weak self] text in
                self?.finalJA = text
            })

            try? await Task.sleep(nanoseconds: 120_000_000)
        } catch {
            isRecordingJA = false
            errorMessage = "éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼(JA): \(error.localizedDescription)"
        }
    }

    func finishAndTranslateJA() {
        asrJA.finishInput()
        isRecordingJA = false

        jaTranslateTask?.cancel()
        jaTranslateTask = Task { @MainActor [weak self] in
            guard let self else { return }

            let deadline = Date().addingTimeInterval(1.0)
            while Date() < deadline && self.finalJA.isEmpty && !self.asrJA.didEmitFinal {
                try? await Task.sleep(nanoseconds: 100_000_000)
                if Task.isCancelled { return }
            }
            if self.finalJA.isEmpty { self.finalJA = self.partialJA }

            self.asrJA.cancelAll()

            await self.runTranslationAndTTS_JAtoEN()
        }
    }

    private func runTranslationAndTTS_JAtoEN() async {
        guard !finalJA.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }

        // âœ… ã“ã“ã§ã€Œç„¡æ–™30å›ã€ã‚’æ¶ˆè²»ï¼ˆè³¼èª­ä¸­ã¯æ¶ˆè²»ã—ãªã„ï¼‰
        if !freeLimiter.consumeOneIfPossible() {
            errorMessage = "ç„¡æ–™\(freeLimiter.quotaTotal)å›ã‚’ä½¿ã„åˆ‡ã‚Šã¾ã—ãŸã€‚ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã”æ¤œè¨ãã ã•ã„ã€‚"
            return
        }

        isTranslating = true
        defer { isTranslating = false }

        #if canImport(Translation)
        guard isSystemTranslationAvailable, let s = sessionJAtoEN else {
            enFromJA = "(ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³æœªå¯¾å¿œã®ãŸã‚åŸæ–‡ã‚’è¡¨ç¤º)\n\(finalJA)"
            appendConversationEntry(
                speaker: "è‡ªåˆ†",
                direction: "JAâ†’\(appConfig.partnerLangCode.uppercased())",
                sourceLabel: "æ—¥æœ¬èªï¼ˆåŸæ–‡ï¼‰",
                targetLabel: "ç›¸æ‰‹è¨€èªï¼ˆåŸæ–‡ï¼‰",
                sourceText: finalJA,
                targetText: enFromJA
            )
            return
        }

        do {
            let res = try await s.translate(finalJA)
            if Task.isCancelled { return }
            let translated = res.targetText
            enFromJA = translated

            appendConversationEntry(
                speaker: "è‡ªåˆ†",
                direction: "JAâ†’\(appConfig.partnerLangCode.uppercased())",
                sourceLabel: "æ—¥æœ¬èª",
                targetLabel: "ç›¸æ‰‹è¨€èª",
                sourceText: finalJA,
                targetText: translated
            )

            tts.speakEnglish(translated)
        } catch is CancellationError {
            return
        } catch {
            let nsErr = error as NSError
            if nsErr.domain == "TranslationErrorDomain" || nsErr.code == 4097 {
                isSystemTranslationAvailable = false
                errorMessage = "ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³ï¼ˆJAâ†’\(appConfig.partnerLangCode.uppercased())ï¼‰ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚\nåŸæ–‡è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚"
                enFromJA = "(ã‚·ã‚¹ãƒ†ãƒ ç¿»è¨³ã‚¨ãƒ©ãƒ¼: åŸæ–‡ã‚’è¡¨ç¤º)\n\(finalJA)"
            } else {
                errorMessage = "ç¿»è¨³ã‚¨ãƒ©ãƒ¼(JAâ†’\(appConfig.partnerLangCode.uppercased())): \(nsErr.localizedDescription)"
                enFromJA = "(ç¿»è¨³ã‚¨ãƒ©ãƒ¼)\n\(finalJA)"
            }

            appendConversationEntry(
                speaker: "è‡ªåˆ†",
                direction: "JAâ†’\(appConfig.partnerLangCode.uppercased())",
                sourceLabel: "æ—¥æœ¬èªï¼ˆåŸæ–‡ï¼‰",
                targetLabel: "ç›¸æ‰‹è¨€èªï¼ˆåŸæ–‡ï¼‰",
                sourceText: finalJA,
                targetText: enFromJA
            )
        }
        #else
        enFromJA = "(Translationãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æœªå¯¾å¿œç’°å¢ƒ: JAâ†’\(appConfig.partnerLangCode.uppercased()))"
        appendConversationEntry(
            speaker: "è‡ªåˆ†",
            direction: "JAâ†’\(appConfig.partnerLangCode.uppercased())",
            sourceLabel: "æ—¥æœ¬èª",
            targetLabel: "ç›¸æ‰‹è¨€èª",
            sourceText: finalJA,
            targetText: enFromJA
        )
        #endif
    }

    // MARK: - ãƒ­ã‚°ä¿å­˜é–¢é€£ï¼ˆä»¥ä¸‹ãã®ã¾ã¾ï¼‰
    func forceFlushLogNow() { flushCurrentLogToFile() }

    func deleteLog(_ log: ConversationLog) {
        let fm = FileManager.default
        let trashDir = trashDirectory()
        let destURL = trashDir.appendingPathComponent(log.url.lastPathComponent)

        do {
            if fm.fileExists(atPath: destURL.path) {
                try? fm.removeItem(at: destURL)
            }
            try fm.moveItem(at: log.url, to: destURL)

            savedLogs.removeAll { $0.id == log.id || $0.url == log.url }

            let attrs = try? fm.attributesOfItem(atPath: destURL.path)
            let cdate = (attrs?[.creationDate] as? Date) ?? log.createdAt
            let trashed = ConversationLog(id: UUID(), url: destURL, createdAt: cdate)
            trashedLogs.insert(trashed, at: 0)
        } catch {
            errorMessage = "ã‚´ãƒŸç®±ç§»å‹•ã‚¨ãƒ©ãƒ¼: \(error.localizedDescription)"
        }
    }

    func restoreFromTrash(_ log: ConversationLog) {
        let fm = FileManager.default
        let destURL = logsDirectory().appendingPathComponent(log.url.lastPathComponent)

        do {
            if fm.fileExists(atPath: destURL.path) {
                try? fm.removeItem(at: destURL)
            }
            try fm.moveItem(at: log.url, to: destURL)

            trashedLogs.removeAll { $0.id == log.id || $0.url == log.url }

            let attrs = try? fm.attributesOfItem(atPath: destURL.path)
            let cdate = (attrs?[.creationDate] as? Date) ?? log.createdAt
            let restored = ConversationLog(id: UUID(), url: destURL, createdAt: cdate)
            savedLogs.insert(restored, at: 0)
        } catch {
            errorMessage = "å¾©å…ƒã‚¨ãƒ©ãƒ¼: \(error.localizedDescription)"
        }
    }

    func permanentlyDelete(_ log: ConversationLog) {
        do {
            try FileManager.default.removeItem(at: log.url)
        } catch {
            errorMessage = "å®Œå…¨å‰Šé™¤ã‚¨ãƒ©ãƒ¼: \(error.localizedDescription)"
        }
        trashedLogs.removeAll { $0.id == log.id || $0.url == log.url }
    }

    func readLog(_ log: ConversationLog) -> String {
        (try? String(contentsOf: log.url, encoding: .utf8)) ?? ""
    }

    private func logsDirectory() -> URL {
        let base = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let dir = base.appendingPathComponent(appConfig.logsFolderName, isDirectory: true)
        if !FileManager.default.fileExists(atPath: dir.path) {
            try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        }
        return dir
    }

    private func trashDirectory() -> URL {
        let dir = logsDirectory().appendingPathComponent("Trash", isDirectory: true)
        if !FileManager.default.fileExists(atPath: dir.path) {
            try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        }
        return dir
    }

    private func loadExistingLogs() {
        let fm = FileManager.default

        let dir = logsDirectory()
        var list: [ConversationLog] = []
        if let urls = try? fm.contentsOfDirectory(at: dir,
                                                  includingPropertiesForKeys: [.creationDateKey],
                                                  options: [.skipsHiddenFiles]) {
            for url in urls where url.pathExtension == "txt" {
                if url.lastPathComponent == "Trash" { continue }
                let attrs = try? fm.attributesOfItem(atPath: url.path)
                let cdate = (attrs?[.creationDate] as? Date) ?? Date()
                let log = ConversationLog(id: UUID(), url: url, createdAt: cdate)
                list.append(log)
            }
        }
        list.sort { $0.createdAt > $1.createdAt }
        savedLogs = list

        let trashDir = trashDirectory()
        var tlist: [ConversationLog] = []
        if let urls = try? fm.contentsOfDirectory(at: trashDir,
                                                  includingPropertiesForKeys: [.creationDateKey],
                                                  options: [.skipsHiddenFiles]) {
            for url in urls where url.pathExtension == "txt" {
                let attrs = try? fm.attributesOfItem(atPath: url.path)
                let cdate = (attrs?[.creationDate] as? Date) ?? Date()
                let log = ConversationLog(id: UUID(), url: url, createdAt: cdate)
                tlist.append(log)
            }
        }
        tlist.sort { $0.createdAt > $1.createdAt }
        trashedLogs = tlist
    }

    private func appendConversationEntry(
        speaker: String,
        direction: String,
        sourceLabel: String,
        targetLabel: String,
        sourceText: String,
        targetText: String
    ) {
        guard isLoggingEnabled else { return }

        let now = Date()

        if let start = currentLogStartDate,
           now.timeIntervalSince(start) > 5 * 60 {
            flushCurrentLogToFile()
        }

        if currentLogStartDate == nil {
            currentLogStartDate = now
            currentLogBuffer = ""
            enToJaOnlyBuffer = ""
        }

        let timeStr = Self.logTimeFormatter.string(from: now)

        let entry = """
        [\(timeStr)] \(speaker) (\(direction))
        \(sourceLabel): \(sourceText)
        \(targetLabel): \(targetText)

        """

        currentLogBuffer.append(entry)
    }

    private func appendENtoJAStudyLine(_ jaText: String) {
        guard isLoggingEnabled else { return }

        if enToJaOnlyBuffer.isEmpty {
            enToJaOnlyBuffer.append("ã€ç›¸æ‰‹è¨€èªâ†’æ—¥æœ¬èª ç¿»è¨³ãƒ­ã‚°ã€‘\n\n")
        }
        enToJaOnlyBuffer.append(jaText)
        enToJaOnlyBuffer.append("\n")
    }

    private func flushCurrentLogToFile() {
        guard let start = currentLogStartDate else {
            currentLogStartDate = nil
            currentLogBuffer = ""
            enToJaOnlyBuffer = ""
            return
        }

        let dir = logsDirectory()
        let df = DateFormatter()
        df.locale = Locale(identifier: "ja_JP")
        df.dateFormat = "yyyyMMdd_HHmmss"

        do {
            if !currentLogBuffer.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                let name = "\(appConfig.logFilePrefix)_\(df.string(from: start)).txt"
                let url = dir.appendingPathComponent(name)
                try currentLogBuffer.write(to: url, atomically: true, encoding: .utf8)
                let log = ConversationLog(id: UUID(), url: url, createdAt: start)
                savedLogs.insert(log, at: 0)
            }

            if !enToJaOnlyBuffer.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                let nameJA = "\(appConfig.viToJaLogFilePrefix)_\(df.string(from: start)).txt"
                let urlJA = dir.appendingPathComponent(nameJA)
                try enToJaOnlyBuffer.write(to: urlJA, atomically: true, encoding: .utf8)
                let logJA = ConversationLog(id: UUID(), url: urlJA, createdAt: start)
                savedLogs.insert(logJA, at: 0)
            }
        } catch {
            errorMessage = "ãƒ­ã‚°ä¿å­˜ã‚¨ãƒ©ãƒ¼: \(error.localizedDescription)"
        }

        currentLogStartDate = nil
        currentLogBuffer = ""
        enToJaOnlyBuffer = ""
    }
}

// =====================================
// ã‚´ãƒŸç®±ã‚¤ãƒ©ã‚¹ãƒˆ View
// =====================================
struct TrashCanIllustrationView: View {
    let count: Int
    let isOpen: Bool

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 10)
                .fill(Color(.secondarySystemBackground))
                .frame(width: 80, height: 80)
                .shadow(radius: 2, y: 1)

            RoundedRectangle(cornerRadius: 8)
                .strokeBorder(Color(.systemGray3), lineWidth: 1.5)
                .frame(width: 80, height: 80)

            RoundedRectangle(cornerRadius: 4)
                .fill(Color(.systemGray3))
                .frame(width: 64, height: 10)
                .offset(y: isOpen ? -62 : -42)
                .rotationEffect(
                    isOpen ? .degrees(-55) : .degrees(0),
                    anchor: .bottomLeading
                )
                .shadow(radius: isOpen ? 2 : 0, y: 1)

            VStack(spacing: 3) {
                Spacer()
                Image(systemName: count > 0 ? "folder.fill" : "folder")
                    .font(.system(size: 20, weight: .semibold))
                Text(count > 0 ? "\(count) ä»¶" : "ç©º")
                    .font(.caption2)
                    .foregroundStyle(.secondary)
                Spacer()
            }
            .padding(.vertical, 10)
        }
        .frame(width: 90, height: 90)
        .overlay(
            Text("ã‚´ãƒŸç®±")
                .font(.caption2)
                .padding(.top, 76),
            alignment: .top
        )
    }
}

// =====================================
// æ±ç”¨ï¼šå·¦ã«ã‚¹ãƒ©ã‚¤ãƒ‰ã—ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã™ã‚‹è¡Œ
// =====================================
struct SwipeActionRow<Content: View>: View {
    let actionLabel: String
    let systemImage: String
    let onAction: () -> Void
    let content: () -> Content

    @State private var offsetX: CGFloat = 0

    var body: some View {
        ZStack(alignment: .trailing) {
            HStack {
                Spacer()
                HStack(spacing: 6) {
                    Image(systemName: systemImage)
                        .font(.system(size: 14, weight: .semibold))
                    Text(actionLabel)
                        .font(.caption)
                }
                .foregroundColor(.white)
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(Color.red)
                .clipShape(Capsule())
                .padding(.trailing, 16)
            }

            content()
                .background(Color.clear)
                .offset(x: offsetX)
                .gesture(
                    DragGesture(minimumDistance: 10, coordinateSpace: .local)
                        .onChanged { value in
                            if value.translation.width < 0 {
                                offsetX = value.translation.width
                            }
                        }
                        .onEnded { value in
                            if value.translation.width < -80 {
                                withAnimation(.easeOut(duration: 0.12)) {
                                    offsetX = -120
                                }
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.12) {
                                    onAction()
                                    offsetX = 0
                                }
                            } else {
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                    offsetX = 0
                                }
                            }
                        }
                )
        }
    }
}

// =====================================
// èµ·å‹•ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ç”¨ Viewï¼ˆç´„10ç§’ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰
// =====================================
struct LaunchSplashView: View {
    @Binding var showSplash: Bool

    @State private var scale: CGFloat = 0.4
    @State private var opacity: Double = 0.0

    var body: some View {
        ZStack {
            Color(.systemBackground)
                .ignoresSafeArea()

            Image("LaunchIcon")
                .resizable()
                .scaledToFit()
                .frame(width: 180, height: 180)
                .scaleEffect(scale)
                .opacity(opacity)
        }
        .onAppear {
            withAnimation(.easeOut(duration: 2.5)) {
                opacity = 1.0
                scale = 1.0
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                withAnimation(.easeInOut(duration: 5.0)) {
                    scale = 3.2
                    opacity = 0.0
                }
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + 9.8) {
                showSplash = false
            }
        }
    }
}

// =====================================
// UI
// =====================================
struct ContentView: View {
    @StateObject private var vm = DoujituVM()
    @State private var dragJA: CGSize = .zero

    @State private var selectedLog: ConversationLog?
    @State private var selectedLogText: String = ""

    @State private var isTrashOpen: Bool = false
    @State private var showSplash: Bool = true

    @State private var showResourceAlert: Bool = false
    @State private var resourceDownloadAllowed: Bool = false

    private let knobMaxRadius: CGFloat = 56
    private let outerSize: CGFloat = 112
    private let innerSize: CGFloat = 60

    var body: some View {
        ZStack {
            ScrollView {
                VStack(spacing: 6) {

                    Group {
                        VStack(spacing: 6) {
                            Text(appConfig.appDisplayName)
                                .font(.system(size: 22, weight: .heavy, design: .rounded))
                                .tracking(1.5)
                                .padding(.horizontal, 18)
                                .padding(.vertical, 6)
                                .background(
                                    Capsule().fill(
                                        LinearGradient(
                                            colors: [
                                                Color.pink.opacity(0.9),
                                                Color.orange.opacity(0.9)
                                            ],
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                )
                                .foregroundColor(.white)
                        }
                    }
                    .padding(.horizontal, 12)

                    if !resourceDownloadAllowed {
                        VStack(spacing: 6) {
                            Text("ç¿»è¨³ç”¨ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦")
                                .font(.headline)
                                .frame(maxWidth: .infinity, alignment: .leading)

                            Text("ã“ã®ã‚¢ãƒ—ãƒªã®ç¿»è¨³æ©Ÿèƒ½ã‚’åˆ©ç”¨ã™ã‚‹ã«ã¯ã€Apple ã®ã‚µãƒ¼ãƒã‹ã‚‰ç¿»è¨³ç”¨ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿ï¼ˆç´„ 150MBï¼‰ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚Wi-Fi ç’°å¢ƒã§ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .frame(maxWidth: .infinity, alignment: .leading)

                            Button {
                                showResourceAlert = true
                            } label: {
                                Text("ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦é–‹å§‹")
                                    .font(.subheadline)
                                    .fontWeight(.semibold)
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 8)
                                    .background(Color.blue)
                                    .foregroundColor(.white)
                                    .cornerRadius(8)
                            }
                        }
                        .padding(12)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(Color(.secondarySystemBackground))
                        )
                        .padding(.horizontal, 12)
                    }

                    Group {
                        VStack(spacing: 4) {
                            Text("ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èª â†’ æ—¥æœ¬èªï¼ˆå¸¸æ™‚ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰")
                                .font(.headline)
                                .frame(maxWidth: .infinity, alignment: .leading)

                            LabeledContent("ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èªï¼ˆé€”ä¸­ï¼‰") {
                                Text(vm.enLivePartial.isEmpty ? "â€¦" : vm.enLivePartial)
                                    .multilineTextAlignment(.leading)
                                    .lineLimit(2)
                                    .truncationMode(.tail)
                                    .fixedSize(horizontal: false, vertical: true)
                            }

                            LabeledContent("æ—¥æœ¬èª\nï¼ˆè‡ªå‹•ç¿»è¨³çµæœï¼‰") {
                                ScrollView {
                                    Text(vm.jaFromEN.isEmpty ? "â€¦" : vm.jaFromEN)
                                        .multilineTextAlignment(.leading)
                                        .textSelection(.enabled)
                                        .fixedSize(horizontal: false, vertical: true)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                        .padding(8)
                                }
                                .frame(minHeight: 280, maxHeight: 560)
                                .background(
                                    RoundedRectangle(cornerRadius: 10)
                                        .fill(Color(.secondarySystemBackground))
                                )
                            }
                        }
                    }
                    .padding(.horizontal, 12)

                    Divider().padding(.vertical, 4)

                    Group {
                        VStack(spacing: 4) {
                            Text("æ—¥æœ¬èª â†’ ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èªï¼ˆæŠ¼ã—ã¦è©±ã™ï¼é›¢ã™ã¨ç¿»è¨³ï¼‹éŸ³å£°ï¼‰")
                                .font(.headline)
                                .frame(maxWidth: .infinity, alignment: .leading)

                            LabeledContent("æ—¥æœ¬èªï¼ˆé€”ä¸­ï¼‰") {
                                Text(vm.partialJA.isEmpty ? "â€¦" : vm.partialJA)
                                    .multilineTextAlignment(.leading)
                                    .lineLimit(2)
                                    .truncationMode(.tail)
                                    .fixedSize(horizontal: false, vertical: true)
                            }

                            LabeledContent("ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èªï¼ˆç¿»è¨³çµæœï¼‰") {
                                Text(vm.enFromJA.isEmpty ? "â€¦" : vm.enFromJA)
                                    .multilineTextAlignment(.leading)
                                    .foregroundStyle(.blue)
                                    .fixedSize(horizontal: false, vertical: true)
                                    .frame(minHeight: 60, alignment: .topLeading)
                            }

                            ZStack {
                                Circle()
                                    .fill(
                                        LinearGradient(
                                            colors: [Color.pink.opacity(0.9), Color.orange.opacity(0.9)],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        )
                                    )
                                    .frame(width: outerSize, height: outerSize)
                                    .shadow(radius: 4, y: 2)
                                    .overlay(
                                        VStack {
                                            Spacer()
                                            Text(vm.isRecordingJA ? "éŒ²éŸ³ä¸­â€¦ é›¢ã™ã¨ç¿»è¨³" : "æŒ‡ã§æŠ¼ã—ãªãŒã‚‰è©±ã™")
                                                .font(.caption2)
                                                .foregroundStyle(.white)
                                                .padding(.bottom, 8)
                                                .lineLimit(2)
                                        }
                                    )

                                Circle()
                                    .fill(.ultraThinMaterial)
                                    .overlay(
                                        Image(systemName: vm.isRecordingJA ? "waveform" : "mic.fill")
                                            .font(.system(size: 24, weight: .semibold))
                                            .foregroundStyle(vm.isRecordingJA ? .red : .primary)
                                    )
                                    .frame(width: innerSize, height: innerSize)
                                    .offset(dragJA)
                                    .gesture(
                                        DragGesture(minimumDistance: 0)
                                            .onChanged { value in
                                                if !vm.isRecordingJA && !vm.isTranslating {
                                                    Task { await vm.startRecordingJA() }
                                                }
                                                let dx = value.translation.width
                                                let dy = value.translation.height
                                                let r = sqrt(dx*dx + dy*dy)
                                                if r <= knobMaxRadius {
                                                    dragJA = value.translation
                                                } else {
                                                    let s = knobMaxRadius / max(r, 0.0001)
                                                    dragJA = CGSize(width: dx*s, height: dy*s)
                                                }
                                            }
                                            .onEnded { _ in
                                                withAnimation(.spring(response: 0.35, dampingFraction: 0.7)) {
                                                    dragJA = .zero
                                                }
                                                vm.finishAndTranslateJA()
                                            }
                                    )
                            }
                            .padding(.bottom, 4)
                        }
                    }
                    .padding(.horizontal, 12)

                    if let err = vm.errorMessage, !err.isEmpty {
                        Text(err)
                            .foregroundStyle(.red)
                            .font(.footnote)
                            .padding(.horizontal)
                    }

                    Divider().padding(.vertical, 4)

                    // ==== ä¼šè©±ãƒ­ã‚° ====
                    Group {
                        VStack(spacing: 4) {
                            HStack {
                                Text("ä¼šè©±ãƒ­ã‚°ï¼ˆç´„5åˆ†ã”ã¨ã«è‡ªå‹•ä¿å­˜ï¼‰")
                                    .font(.headline)
                                Spacer()
                                Toggle(isOn: $vm.isLoggingEnabled) {
                                    Text(vm.isLoggingEnabled ? "ON" : "OFF")
                                        .font(.caption)
                                }
                                .labelsHidden()
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)

                            Button {
                                vm.forceFlushLogNow()
                            } label: {
                                HStack(spacing: 4) {
                                    Image(systemName: "square.and.arrow.down")
                                    Text("ç¾åœ¨ã¾ã§ã‚’1ã¤ã®ãƒ­ã‚°ã¨ã—ã¦ä¿å­˜")
                                        .font(.caption)
                                }
                            }

                            if vm.savedLogs.isEmpty {
                                Text("ã¾ã ä¿å­˜ã•ã‚ŒãŸãƒ­ã‚°ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            } else {
                                VStack(alignment: .leading, spacing: 4) {
                                    ForEach(vm.savedLogs) { log in
                                        SwipeActionRow(
                                            actionLabel: "ã‚´ãƒŸç®±ã¸",
                                            systemImage: "trash"
                                        ) {
                                            vm.deleteLog(log)
                                        } content: {
                                            HStack(alignment: .top, spacing: 8) {
                                                VStack(alignment: .leading, spacing: 2) {
                                                    Text(log.displayName)
                                                        .font(.subheadline)
                                                    Text(log.formattedDate)
                                                        .font(.caption2)
                                                        .foregroundStyle(.secondary)
                                                }

                                                Spacer()

                                                Button {
                                                    selectedLogText = vm.readLog(log)
                                                    selectedLog = log
                                                } label: {
                                                    VStack(spacing: 2) {
                                                        Image(systemName: "doc.text.magnifyingglass")
                                                            .font(.system(size: 16, weight: .semibold))
                                                        Text("é–‹ã")
                                                            .font(.caption2)
                                                    }
                                                    .padding(6)
                                                }

                                                if #available(iOS 16.0, *) {
                                                    ShareLink(item: log.url) {
                                                        VStack(spacing: 2) {
                                                            Image(systemName: "square.and.arrow.up")
                                                                .font(.system(size: 16, weight: .semibold))
                                                            Text("å…±æœ‰")
                                                                .font(.caption2)
                                                        }
                                                        .padding(6)
                                                    }
                                                }
                                            }
                                            .padding(4)
                                            .background(
                                                RoundedRectangle(cornerRadius: 8)
                                                    .fill(Color(.secondarySystemBackground))
                                            )
                                        }
                                    }
                                }
                            }

                            Divider().padding(.vertical, 2)

                            VStack(alignment: .leading, spacing: 4) {
                                HStack {
                                    Text("ã‚´ãƒŸç®±")
                                        .font(.headline)
                                    Spacer()
                                }

                                Button {
                                    withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                        isTrashOpen.toggle()
                                    }
                                } label: {
                                    HStack {
                                        Spacer()
                                        TrashCanIllustrationView(
                                            count: vm.trashedLogs.count,
                                            isOpen: isTrashOpen
                                        )
                                        Spacer()
                                    }
                                }
                                .buttonStyle(.plain)

                                if isTrashOpen && !vm.trashedLogs.isEmpty {
                                    VStack(alignment: .leading, spacing: 4) {
                                        ForEach(vm.trashedLogs) { log in
                                            SwipeActionRow(
                                                actionLabel: "å®Œå…¨å‰Šé™¤",
                                                systemImage: "trash.slash"
                                            ) {
                                                vm.permanentlyDelete(log)
                                            } content: {
                                                HStack(alignment: .top, spacing: 8) {
                                                    VStack(alignment: .leading, spacing: 2) {
                                                        Text(log.displayName)
                                                            .font(.subheadline)
                                                        Text(log.formattedDate)
                                                            .font(.caption2)
                                                            .foregroundStyle(.secondary)
                                                    }

                                                    Spacer()

                                                    Button {
                                                        selectedLogText = vm.readLog(log)
                                                        selectedLog = log
                                                    } label: {
                                                        VStack(spacing: 2) {
                                                            Image(systemName: "doc.text.magnifyingglass")
                                                                .font(.system(size: 16, weight: .semibold))
                                                            Text("é–‹ã")
                                                                .font(.caption2)
                                                        }
                                                        .padding(6)
                                                    }

                                                    Button {
                                                        vm.restoreFromTrash(log)
                                                    } label: {
                                                        VStack(spacing: 2) {
                                                            Image(systemName: "arrow.uturn.backward")
                                                                .font(.system(size: 16, weight: .semibold))
                                                            Text("å¾©å…ƒ")
                                                                .font(.caption2)
                                                        }
                                                        .padding(6)
                                                    }
                                                }
                                                .padding(4)
                                                .background(
                                                    RoundedRectangle(cornerRadius: 8)
                                                        .fill(Color(.tertiarySystemBackground))
                                                )
                                            }
                                        }
                                    }
                                    .transition(.move(edge: .bottom).combined(with: .opacity))
                                } else if vm.trashedLogs.isEmpty {
                                    Text("ã‚´ãƒŸç®±ã¯ç©ºã§ã™ã€‚")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                }
                            }
                            .padding(.top, 300)
                        }
                    }
                    .padding(.horizontal, 12)
                    .padding(.bottom, 16)
                }
                .padding(.top, 12)
            }

            if showSplash {
                LaunchSplashView(showSplash: $showSplash)
                    .transition(.opacity)
                    .zIndex(10)
            }
        }
        .onAppear {
            let consent = UserDefaults.standard.bool(forKey: appConfig.resourceConsentUserDefaultsKey)
            resourceDownloadAllowed = consent
            if !consent {
                showResourceAlert = true
            }
        }
        .alert("è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰", isPresented: $showResourceAlert) {
            Button("ã‚­ãƒ£ãƒ³ã‚»ãƒ«", role: .cancel) {
                resourceDownloadAllowed = false
                UserDefaults.standard.set(false, forKey: appConfig.resourceConsentUserDefaultsKey)
            }
            Button("ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰") {
                resourceDownloadAllowed = true
                UserDefaults.standard.set(true, forKey: appConfig.resourceConsentUserDefaultsKey)
                Task { await vm.startENContinuous() }
            }
        } message: {
            Text("ã“ã®ã‚¢ãƒ—ãƒªã®ç¿»è¨³æ©Ÿèƒ½ã‚’åˆ©ç”¨ã™ã‚‹ã«ã¯ã€Apple ã®ã‚µãƒ¼ãƒã‹ã‚‰ç¿»è¨³ç”¨ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿ï¼ˆç´„ 150MBï¼‰ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚Wi-Fi ç’°å¢ƒã§ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚ä»Šã™ããƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã‹ï¼Ÿ")
        }
        .task {
            if resourceDownloadAllowed {
                await vm.startENContinuous()
            }
        }
        .sheet(item: $selectedLog) { log in
            NavigationStack {
                ScrollView {
                    Text(selectedLogText.isEmpty ? "ï¼ˆå†…å®¹ãªã—ï¼‰" : selectedLogText)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding()
                }
                .navigationTitle(log.displayName)
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        Button("é–‰ã˜ã‚‹") { selectedLog = nil }
                    }
                }
            }
        }
        #if canImport(Translation)
        .translationTask(vm.tConfigJAtoEN) { session in
            await vm.bindSessionJAtoEN(session)
        }
        .translationTask(vm.tConfigENtoJA) { session in
            await vm.bindSessionENtoJA(session)
        }
        #endif
    }
}
